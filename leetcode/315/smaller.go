package smaller

type pair struct {
	value         int
	originalIndex int
}

func countSmaller(nums []int) []int {
	if len(nums) == 0 {
		return []int{}
	}

	n := len(nums)
	result := make([]int, n)

	newNums := make([]pair, n)
	for i := 0; i < n; i++ {
		newNums[i] = pair{value: nums[i], originalIndex: i}
	}

	mergeSortAndCount(newNums, 0, n-1, result)

	// notice we don't care about the sorted array after merge sort finishes.
	// we only wanted the result counts, generated by running merge sort
	return result
}

func mergeSortAndCount(nums []pair, start, end int, result []int) {
	if start >= end {
		return
	}

	mid := (start + end) / 2
	mergeSortAndCount(nums, start, mid, result)
	mergeSortAndCount(nums, mid+1, end, result)

	// left subarray start...mid
	// right subarray mid+1...end
	leftPos := start
	rightPos := mid + 1
	merged := make([]pair, 0)
	numElemsRightArrayLessThanLeftArray := 0
	for leftPos < mid+1 && rightPos <= end {
		if nums[leftPos].value > nums[rightPos].value {
			// this code block is exactly what the problem is asking us for:
			// a number from the right side of the original input array, is smaller
			// than a number from the left side
			//
			// within this code block,
			// nums[rightPos] is smaller than the start of the left sub-array.
			// Since left sub-array is already sorted,
			// nums[rightPos] must also be smaller than the entire remaining left sub-array
			numElemsRightArrayLessThanLeftArray++

			// continue with normal merge sort, merge
			merged = append(merged, nums[rightPos])
			rightPos++
		} else {
			// a number from left side of array, is smaller than a number from
			// right side of array
			result[nums[leftPos].originalIndex] += numElemsRightArrayLessThanLeftArray

			// Continue with normal merge sort
			merged = append(merged, nums[leftPos])
			leftPos++
		}
	}

	// part of normal merge sort, if either left or right sub-array is not empty,
	// move all remaining elements into merged result
	for leftPos < mid+1 {
		result[nums[leftPos].originalIndex] += numElemsRightArrayLessThanLeftArray

		merged = append(merged, nums[leftPos])
		leftPos++
	}

	for rightPos <= end {
		merged = append(merged, nums[rightPos])
		rightPos++
	}

	// part of normal merge sort
	// copy back merged result into array
	pos := start
	for _, m := range merged {
		nums[pos] = m
		pos++
	}
}
